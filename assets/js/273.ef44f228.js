(window.webpackJsonp=window.webpackJsonp||[]).push([[273],{1036:function(t,s,v){"use strict";v.r(s);var _=v(1),a=Object(_.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"应用之异步调用-案例1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用之异步调用-案例1"}},[t._v("#")]),t._v(" 应用之异步调用（案例1）")]),t._v(" "),v("p",[t._v("以调用方角度来讲，如果")]),t._v(" "),v("p",[t._v("需要等待结果返回，才能继续运行就是同步")]),t._v(" "),v("p",[t._v("不需要等待结果返回，就能继续运行就是异步 1")]),t._v(" "),v("h3",{attrs:{id:"设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计"}},[t._v("#")]),t._v(" ) 设计")]),t._v(" "),v("p",[t._v("多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停...")]),t._v(" "),v("h3",{attrs:{id:"_2-结论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-结论"}},[t._v("#")]),t._v(" 2) 结论")]),t._v(" "),v("ul",[v("li",[t._v("比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程")]),t._v(" "),v("li",[t._v("tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程")]),t._v(" "),v("li",[t._v("ui 程序中，开线程进行其他操作，避免阻塞 ui 线程")])]),t._v(" "),v("h2",{attrs:{id:"应用之提高效率-案例1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用之提高效率-案例1"}},[t._v("#")]),t._v(" 应用之提高效率（案例1）")]),t._v(" "),v("p",[t._v("充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("ul",[v("li",[v("p",[t._v("如果是串行执行，那么总共花费的时间是 "),v("code",[t._v("10 + 11 + 9 + 1 = 31ms")])])]),t._v(" "),v("li",[v("p",[t._v("但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 "),v("code",[t._v("11ms")]),t._v(" 最后加上汇总时间只会花费 "),v("code",[t._v("12ms")])])]),t._v(" "),v("li",[v("p",[t._v("注意")]),t._v(" "),v("ul",[v("li",[t._v("需要在多核 cpu 才能提高效率，单核仍然时是轮流执行")])])])]),t._v(" "),v("ol",[v("li",[t._v("设计")])]),t._v(" "),v("blockquote",[v("p",[t._v("代码见【应用之效率-案例1】")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("结论")])]),t._v(" "),v("ul",[v("li",[t._v("单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活")]),t._v(" "),v("li",[t._v("多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的")]),t._v(" "),v("li",[t._v("有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）")]),t._v(" "),v("li",[t._v("也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义")]),t._v(" "),v("li",[t._v("IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化")])])])}),[],!1,null,null,null);s.default=a.exports}}]);