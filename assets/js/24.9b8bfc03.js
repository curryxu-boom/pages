(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{1023:function(v,_,t){"use strict";t.r(_);var e=t(1),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("img",{attrs:{src:t(439)}}),v._v(" "),e("ul",[e("li",[v._v("堆区中主要放的是new 的这个对象，我们经常看到的"),e("code",[v._v("outofmemory")]),v._v("内存溢出这个异常，简单说，就是堆区的数据放满了无法放置这个对象的时候，就会出现内存溢出。我们的垃圾回收器回收的垃圾主要是我们堆区产生的垃圾、所谓的垃圾，就是这个对象没有被引用了，没有地方使用它，那么这个对象就可以被回收了。")]),v._v(" "),e("li",[v._v("当我们创建一个对象的时候，首先是将这个对象放到"),e("code",[v._v("EDEN")]),v._v("区")]),v._v(" "),e("li",[v._v("如果"),e("code",[v._v("EDEN")]),v._v("区的数据放满了---就会触发一次"),e("code",[v._v("轻GC")]),v._v("(触发垃圾回收器来回收数据)---就会将一系列没有使用到的和没有引用的对象给清除掉。")]),v._v(" "),e("li",[v._v("同时将剩余的对象放到"),e("code",[v._v("FROM")]),v._v("区、"),e("code",[v._v("FROM")]),v._v("区经过一段时间之后，也会出现"),e("code",[v._v("FROM")]),v._v("区满的情况---FROM区满的时候，也会触发一次轻GC---这个时候也会将"),e("code",[v._v("FROM")]),v._v("区"),e("code",[v._v("没有引用和使用的对象")]),v._v("给清空，还剩下的一些未清理的对象 移动到TO区，同时TO区会将名字改为FROM区，原来的FROM区改名为TO区 新的FROM区 也有可能放满数据，这个时候又会触发一次轻GC 同时将新的FROM数据放到TO区。这种操作会循环操作"),e("code",[v._v("循环15次")]),v._v("之后，如果这个对象还没有被销毁那么这个对象就被称为"),e("code",[v._v("老不死对象")]),v._v("，这个对象就会被放到"),e("code",[v._v("老年代")]),v._v("。")]),v._v(" "),e("li",[v._v("如果new的是一个"),e("code",[v._v("大对象")]),v._v("----也会被直接放到老年代")]),v._v(" "),e("li",[v._v("老年代也会被放满---老年代如果放满了--就会触发"),e("code",[v._v("FULL GC")]),v._v(" FULL GC 才是真正影响程序性能的GC")])]),v._v(" "),e("h2",{attrs:{id:"为什么jvm要调优"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么jvm要调优"}},[v._v("#")]),v._v(" 为什么JVM要调优？")]),v._v(" "),e("blockquote",[e("ul",[e("li",[e("strong",[v._v("轻GC的响应时间非常快、这个在JVM调优的时候 是可以忽略不计的，FULL GC的产生 就会造成STW(stop the word)的出现")])]),v._v(" "),e("li",[e("strong",[v._v("它的出现会让整个应用程序挂起，全部停下来(只是让程序停下来 应用并没有死)---让垃圾回收器来专门回收 "),e("code",[v._v("STW")]),v._v("的出现才会影响整个程序的性能")])])])]),v._v(" "),e("ul",[e("li",[v._v("所以 JVM 调优主要是有两种\n"),e("ul",[e("li",[v._v("第一：让 FULL GC 产生的次数减少")]),v._v(" "),e("li",[v._v("第二：让 FULL GC 的运行时间变短")])])]),v._v(" "),e("li",[v._v("就是为了提高程序的吞吐量，应用运行的时间/总时间")])]),v._v(" "),e("h2",{attrs:{id:"_1-对象优先在eden区分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-对象优先在eden区分配"}},[v._v("#")]),v._v(" 1.对象优先在EDEN区分配")]),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC(轻GC)。")])]),v._v(" "),e("ul",[e("li",[v._v("我们来进行实际测试一下。在测试之前我们先来看看 Minor Gc 和 Full GC 有什么不同呢？")]),v._v(" "),e("li",[v._v("新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。")]),v._v(" "),e("li",[v._v("老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。")])])]),v._v(" "),e("p",[v._v("我们可以在idea配置如下参数可以看到jvm内存使用情况")]),v._v(" "),e("p",[v._v("添加的参数："),e("code",[v._v("-XX:+PrintGCDetails")])]),v._v(" "),e("img",{attrs:{src:t(440)}}),v._v(" "),e("img",{attrs:{src:t(441)}}),v._v(" "),e("img",{attrs:{src:t(442)}}),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("从上图我们可以看出"),e("code",[v._v("eden")]),v._v("区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少2000多k内存）。")])]),v._v(" "),e("p",[e("strong",[v._v("假如我们再为byte分配内存会出现什么情况呢？")])])]),v._v(" "),e("img",{attrs:{src:t(443)}}),v._v(" "),e("p",[e("strong",[v._v("简单解释一下为什么会出现这种情况：")]),v._v(" 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好通过 "),e("strong",[v._v("分配担保机制")]),v._v(" 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：")]),v._v(" "),e("img",{attrs:{src:t(444)}}),v._v(" "),e("h2",{attrs:{id:"_2-大对象直接放入老年代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-大对象直接放入老年代"}},[v._v("#")]),v._v(" 2.大对象直接放入老年代")]),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。")])]),v._v(" "),e("p",[v._v("为什么要这样呢？")]),v._v(" "),e("p",[v._v("为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率")])]),v._v(" "),e("h2",{attrs:{id:"_3-长期存活的对象将进入老年代"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-长期存活的对象将进入老年代"}},[v._v("#")]),v._v(" 3.长期存活的对象将进入老年代")]),v._v(" "),e("blockquote",[e("ul",[e("li",[e("strong",[v._v("既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。")])]),v._v(" "),e("li",[v._v("为了做到这一点，虚拟机给了每个对象一个对象年龄（Age）计数器。")]),v._v(" "),e("li",[v._v("如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。")]),v._v(" "),e("li",[v._v("对象晋升到老年代的年龄阈值，可以通过参数 "),e("code",[v._v("-XX:MaxTenuringThreshold")]),v._v(" 来设置。")])])])])}),[],!1,null,null,null);_.default=o.exports},439:function(v,_,t){v.exports=t.p+"assets/img/21.65a58e6d.png"},440:function(v,_,t){v.exports=t.p+"assets/img/22.f096d9fb.png"},441:function(v,_,t){v.exports=t.p+"assets/img/23.9ef52b52.png"},442:function(v,_,t){v.exports=t.p+"assets/img/24.69483f66.jpeg"},443:function(v,_,t){v.exports=t.p+"assets/img/25.9884fa52.jpeg"},444:function(v,_,t){v.exports=t.p+"assets/img/26.7f179f69.jpeg"}}]);