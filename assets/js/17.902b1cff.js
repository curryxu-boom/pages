(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{1027:function(l,e,a){"use strict";a.r(e);var v=a(1),_=Object(v.a)({},(function(){var l=this,e=l.$createElement,v=l._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[v("img",{attrs:{src:a(453)}}),l._v(" "),v("ul",[v("li",[l._v("如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。")]),l._v(" "),v("li",[l._v("虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。")]),l._v(" "),v("li",[l._v("因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。")])]),l._v(" "),v("h2",{attrs:{id:"serial-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#serial-收集器"}},[l._v("#")]),l._v(" Serial 收集器")]),l._v(" "),v("blockquote",[v("p",[l._v("开启："),v("code",[l._v("-XX:+UseSerialGC")])])]),l._v(" "),v("blockquote",[v("p",[v("strong",[l._v("Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。")])]),l._v(" "),v("p",[l._v('大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。')]),l._v(" "),v("p",[l._v("新生代采用复制算法")]),l._v(" "),v("p",[l._v("老年代采用标记-整理算法。")])]),l._v(" "),v("img",{attrs:{src:a(454)}}),l._v(" "),v("ul",[v("li",[l._v("虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。")]),l._v(" "),v("li",[l._v("但是"),v("code",[l._v("Serial")]),l._v("收集器有没有优于其他垃圾收集器的地方呢？\n"),v("ul",[v("li",[l._v("当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。")])])])]),l._v(" "),v("h2",{attrs:{id:"parnew-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parnew-收集器"}},[l._v("#")]),l._v(" ParNew 收集器")]),l._v(" "),v("ul",[v("li",[l._v("ParNew 收集器其实就是 Serial 收集器的多线程版本")]),l._v(" "),v("li",[l._v("除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样\n"),v("ul",[v("li",[l._v("新生代采用复制算法")]),l._v(" "),v("li",[l._v("老年代采用标记-整理算法")])])])]),l._v(" "),v("img",{attrs:{src:a(455)}}),l._v(" "),v("ul",[v("li",[l._v("它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。")]),l._v(" "),v("li",[l._v("并行和并发概念补充：\n"),v("ul",[v("li",[l._v("并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。适合科学计算、后台处理等弱交互场景。")]),l._v(" "),v("li",[l._v("并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。适合Web应用。")])])])]),l._v(" "),v("h2",{attrs:{id:"parallel-scavenge-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge-收集器"}},[l._v("#")]),l._v(" Parallel Scavenge 收集器")]),l._v(" "),v("p",[l._v("jdk8 默认的收集器")]),l._v(" "),v("p",[v("code",[l._v("-XX:+UseParallelGC")]),l._v(" (新生代)  "),v("code",[l._v("-XX:+UseParallelOldGC")]),l._v("（老生代）")]),l._v(" "),v("blockquote",[v("p",[v("strong",[l._v("Parallel Scavenge 收集器类似于 ParNew  收集器，是Server 模式（内存大于2G，2个cpu）下的默认收集器，那么它有什么特别之处呢？")])])]),l._v(" "),v("ul",[v("li",[l._v("Parallel Scavenge 收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）")]),l._v(" "),v("li",[l._v("所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值")]),l._v(" "),v("li",[l._v("Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择")]),l._v(" "),v("li",[l._v("新生代采用复制算法")]),l._v(" "),v("li",[l._v("老年代采用标记-整理算法")])]),l._v(" "),v("img",{attrs:{src:a(456)}}),l._v(" "),v("h2",{attrs:{id:"serial-old-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#serial-old-收集器"}},[l._v("#")]),l._v(" Serial Old 收集器")]),l._v(" "),v("ul",[v("li",[l._v("Serial 收集器的老年代版本，它同样是一个单线程收集器")]),l._v(" "),v("li",[l._v("它主要有两大用途：\n"),v("ul",[v("li",[l._v("在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用")]),l._v(" "),v("li",[l._v("作为 CMS 收集器的后备方案")])])])]),l._v(" "),v("h2",{attrs:{id:"parallel-old-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parallel-old-收集器"}},[l._v("#")]),l._v(" Parallel Old 收集器")]),l._v(" "),v("ul",[v("li",[l._v("Parallel Scavenge 收集器的老年代版本")]),l._v(" "),v("li",[l._v("使用多线程和"),v("code",[l._v("标记-整理")]),l._v("算法")]),l._v(" "),v("li",[l._v("在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器")])]),l._v(" "),v("h2",{attrs:{id:"cms-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cms-收集器"}},[l._v("#")]),l._v(" CMS 收集器")]),l._v(" "),v("p",[v("code",[l._v("-XX:+UseConcMarkSweepGC(old) -XX:+UseParNewGC")])]),l._v(" "),v("p",[v("strong",[l._v("CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器")])]),l._v(" "),v("ul",[v("li",[l._v("它非常符合在注重用户体验的应用上使用，它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作")]),l._v(" "),v("li",[l._v("从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 "),v("code",[l._v("标记-清除")]),l._v("算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤\n"),v("ul",[v("li",[l._v("初始标记： 暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快")]),l._v(" "),v("li",[l._v("并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方")]),l._v(" "),v("li",[l._v("重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短")]),l._v(" "),v("li",[l._v("并发清除： 开启用户线程，同时GC线程开始对未标记的区域做清扫")])])])]),l._v(" "),v("img",{attrs:{src:a(457)}}),l._v(" "),v("p",[l._v("从它的名字就可以看出它是一款优秀的垃圾收集器")]),l._v(" "),v("ul",[v("li",[l._v("主要优点：并发收集、低停顿。但是它有下面三个明显的缺点\n"),v("ul",[v("li",[l._v("对CPU资源敏感（会和服务抢资源）")]),l._v(" "),v("li",[l._v("无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了")]),l._v(" "),v("li",[l._v("它使用的回收算法-"),v("code",[l._v("标记-清除")]),l._v("算法会导致收集结束时会有大量空间碎片产生")])])])]),l._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[l._v("CMS的相关参数\n -XX:+UseConcMarkSweepGC 启用cms \n -XX:ConcGCThreads: 并发的GC线程数（并非STW时间，而是和服务一起执行的线程数）\n -XX:+UseCMSCompactAtFullCollection: FullGC 之后做压缩（减少碎片）\n -XX:CMSFullGCsBeforeCompaction: 多少次FullGC之后压缩一次（因压缩非常的消耗时间，所以不能每次FullGC都做）\n -XX:CMSInitiatingOccupancyFraction: 触发FulGC条件（默认是92）\n -XX:+UseCMSInitiatingOccupancyOnly: 是否动态调节\n -XX:+CMSScavengeBeforeRemark: FullGC 之前先做YGC（一般这个参数是打开的）\n -XX:+CMSClassUnloadingEnabled: 启用回收Perm区（jdk1.7及以前）\n")])]),l._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[l._v("1")]),v("br"),v("span",{staticClass:"line-number"},[l._v("2")]),v("br"),v("span",{staticClass:"line-number"},[l._v("3")]),v("br"),v("span",{staticClass:"line-number"},[l._v("4")]),v("br"),v("span",{staticClass:"line-number"},[l._v("5")]),v("br"),v("span",{staticClass:"line-number"},[l._v("6")]),v("br"),v("span",{staticClass:"line-number"},[l._v("7")]),v("br"),v("span",{staticClass:"line-number"},[l._v("8")]),v("br"),v("span",{staticClass:"line-number"},[l._v("9")]),v("br")])]),v("h2",{attrs:{id:"g1-收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#g1-收集器"}},[l._v("#")]),l._v(" G1 收集器")]),l._v(" "),v("p",[v("code",[l._v("-XX:+UseG1GC")])]),l._v(" "),v("blockquote",[v("p",[v("strong",[l._v("G1 (Garbage-First)是一款面向服务器的垃圾收集器 主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征")])])]),l._v(" "),v("img",{attrs:{src:a(458)}}),l._v(" "),v("img",{attrs:{src:a(459)}}),l._v(" "),v("ul",[v("li",[l._v("G1 将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region 的集合")]),l._v(" "),v("li",[l._v("分配大对象（直接进 Humongous 区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC")]),l._v(" "),v("li",[l._v("被视为 JDK1.7 中HotSpot虚拟机的一个重要进化特征。它具备以下特点\n"),v("ul",[v("li",[l._v("并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行")]),l._v(" "),v("li",[l._v("分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念")]),l._v(" "),v("li",[l._v("空间整合：与 CMS 的"),v("code",[l._v("标记--清除")]),l._v("算法不同，G1从整体来看是基于"),v("code",[l._v("标记-整理")]),l._v("算法实现的收集器；从局部上来看是基于“复制”算法实现的")]),l._v(" "),v("li",[l._v("可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集")])])]),l._v(" "),v("li",[l._v("G1收集器的运作大致分为以下几个步骤\n"),v("ul",[v("li",[l._v("初始标记（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关")]),l._v(" "),v("li",[l._v("并发标记（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象")]),l._v(" "),v("li",[l._v("最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期")]),l._v(" "),v("li",[l._v("筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率")])])])]),l._v(" "),v("img",{attrs:{src:a(460)}}),l._v(" "),v("ul",[v("li",[l._v("G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率")]),l._v(" "),v("li",[l._v("G1垃圾收集分类\n"),v("ul",[v("li",[l._v("YoungGC\n"),v("ul",[v("li",[l._v("新对象进入Eden区")]),l._v(" "),v("li",[l._v("存活对象拷贝到Survivor区")]),l._v(" "),v("li",[l._v("存活时间达到年龄阈值时，对象晋升到Old区")])])]),l._v(" "),v("li",[l._v("MixedGC\n"),v("ul",[v("li",[l._v("不是FullGC，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)")])])])])]),l._v(" "),v("li",[l._v("global concurrent marking （全局并发标记）")]),l._v(" "),v("li",[l._v("Initial marking phase: 标记GC Root，STW")]),l._v(" "),v("li",[l._v("Root region scanning phase： 标记存活Region")]),l._v(" "),v("li",[l._v("Concurrent marking phase： 标记存活的对象")]),l._v(" "),v("li",[l._v("Remark phase :重新标记,STW")]),l._v(" "),v("li",[l._v("Cleanup phase: 部分STW")]),l._v(" "),v("li",[l._v("相关参数\n"),v("ul",[v("li",[v("code",[l._v("G1MixedGCLiveThresholdPercent")]),l._v("  Old 区的 region 被回收的时候的存活对象占比")]),l._v(" "),v("li",[v("code",[l._v("G1MixedGCCountTarget")]),l._v("： 一次 global concurrent marking 之后，最多执行Mixed GC的次数")]),l._v(" "),v("li",[v("code",[l._v("G1OldCSetRegionThresholdPercent")]),l._v("  一次Mixed GC中能被选入CSet的最多old区的region数量")])])]),l._v(" "),v("li",[l._v("触发的时机\n"),v("ul",[v("li",[v("code",[l._v("InitiatingHeapOccupancyPercent")]),l._v(":堆占有率达到这个值则触发 global concurrent marking，默认45%")]),l._v(" "),v("li",[v("code",[l._v("G1HeapWastePercent")]),l._v(": 在 global concurrent marking 结束之后，可以知道区有多少空间要被回收，在每次 YGC 之后和再次发生")]),l._v(" "),v("li",[l._v("Mixed GC 之前，会检查垃圾占比是否达到了此参数，只有达到了，下次才会发生Mixed GC")])])])])])}),[],!1,null,null,null);e.default=_.exports},453:function(l,e,a){l.exports=a.p+"assets/img/34.e1be8d7a.png"},454:function(l,e,a){l.exports=a.p+"assets/img/35.9f7788c5.png"},455:function(l,e,a){l.exports=a.p+"assets/img/36.c08364f8.png"},456:function(l,e,a){l.exports=a.p+"assets/img/37.853bedfa.png"},457:function(l,e,a){l.exports=a.p+"assets/img/38.3bfa0e1a.png"},458:function(l,e,a){l.exports=a.p+"assets/img/39.3df8e343.png"},459:function(l,e,a){l.exports=a.p+"assets/img/40.679d8ec5.png"},460:function(l,e,a){l.exports=a.p+"assets/img/41.ee86b923.png"}}]);