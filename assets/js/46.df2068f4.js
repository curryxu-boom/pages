(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{1022:function(_,v,t){"use strict";t.r(v);var a=t(1),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("blockquote",[a("p",[a("strong",[_._v("堆中几乎放着所有的对象实例，堆中的垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）")])])]),_._v(" "),a("h2",{attrs:{id:"_1-引用计数法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数法"}},[_._v("#")]),_._v(" 1.引用计数法")]),_._v(" "),a("ul",[a("li",[_._v("给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。")]),_._v(" "),a("li",[_._v("这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。")]),_._v(" "),a("li",[_._v("所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，")]),_._v(" "),a("li",[_._v("于是引用计数算法无法通知 GC 回收器回收他们。")])]),_._v(" "),a("img",{attrs:{src:t(436)}}),_._v(" "),a("h2",{attrs:{id:"_2-可达性分析算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-可达性分析算法"}},[_._v("#")]),_._v(" 2.可达性分析算法")]),_._v(" "),a("blockquote",[a("p",[a("strong",[_._v("这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。")])]),_._v(" "),a("p",[a("strong",[_._v("GC Roots根节点")]),_._v("：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等")])]),_._v(" "),a("img",{attrs:{src:t(437)}}),_._v(" "),a("h2",{attrs:{id:"_3-finalize-方法最终判定对象是否存活"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-finalize-方法最终判定对象是否存活"}},[_._v("#")]),_._v(" 3.finalize()方法最终判定对象是否存活")]),_._v(" "),a("ul",[a("li",[_._v("即使在可达性分析算法中不可达的对象，也并非是"),a("code",[_._v("非死不可")]),_._v("的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。")]),_._v(" "),a("li",[_._v("标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。\n"),a("ul",[a("li",[_._v("第一次标记、并进行一次筛选。筛选的条件是此对象是否有必要执行"),a("code",[_._v("finalize()")]),_._v("方法。当对象没有覆盖 finalize 方法，或者 finzlize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，"),a("span",{staticStyle:{color:"red"}},[_._v("对象被回收")]),_._v("。")]),_._v(" "),a("li",[_._v("第二次标记、如果这个对象被判定为有必要执行 finalize（）方法，那么这个对象将会被放置在一个名为："),a("code",[_._v("F-Queue")]),_._v(" 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的 "),a("code",[_._v("Finalizer")]),_._v(" 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象 finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。")])])]),_._v(" "),a("li",[_._v("finalize() 方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记")]),_._v(" "),a("li",[_._v("如果对象要在 finalize() 中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。")])]),_._v(" "),a("img",{attrs:{src:t(438)}}),_._v(" "),a("h2",{attrs:{id:"_4-如何判断常量是废弃常量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何判断常量是废弃常量"}},[_._v("#")]),_._v(" 4.如何判断常量是废弃常量")]),_._v(" "),a("ul",[a("li",[_._v("运行时常量池主要回收的是废弃的常量。那我们如何判断一个常量是废弃常量呢？")]),_._v(" "),a("li",[_._v('假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。')])]),_._v(" "),a("h2",{attrs:{id:"_5-如何判断类是无用的类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何判断类是无用的类"}},[_._v("#")]),_._v(" 5.如何判断类是无用的类")]),_._v(" "),a("ul",[a("li",[_._v("方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？")]),_._v(" "),a("li",[_._v("判定一个常量是否是"),a("code",[_._v("废弃常量")]),_._v("比较简单，而要判定一个类是否是"),a("code",[_._v("无用的类")]),_._v("的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 "),a("code",[_._v("无用的类")]),_._v(" "),a("ul",[a("li",[_._v("1.该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。")]),_._v(" "),a("li",[_._v("2.加载该类的 "),a("code",[_._v("ClassLoader")]),_._v(" 已经被回收。")]),_._v(" "),a("li",[_._v("3.该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。")])])]),_._v(" "),a("li",[_._v("虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是"),a("code",[_._v("可以")]),_._v("，而并不是和对象一样不使用了就会必然被回收。")])])])}),[],!1,null,null,null);v.default=e.exports},436:function(_,v,t){_.exports=t.p+"assets/img/27.0afe8eb3.png"},437:function(_,v,t){_.exports=t.p+"assets/img/28.7be4dd56.png"},438:function(_,v,t){_.exports=t.p+"assets/img/29.5da13ac3.png"}}]);