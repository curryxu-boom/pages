(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{1061:function(t,n,o){"use strict";o.r(n);var e=o(1),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,o=t._self._c||n;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[o("strong",[t._v("为了避免临界区的竞态条件发生，有多种手段可以达到目的。")])]),t._v(" "),o("ul",[o("li",[t._v("​\t阻塞式的解决方案：synchronized，Lock")]),t._v(" "),o("li",[t._v("​\t非阻塞式的解决方案：原子变量")])]),t._v(" "),o("p",[t._v("本节使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换")]),t._v(" "),o("blockquote",[o("p",[o("strong",[t._v("注意：")])]),t._v(" "),o("p",[o("strong",[t._v("虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：")])]),t._v(" "),o("p",[t._v("​\t\t互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码")]),t._v(" "),o("p",[t._v("​\t\t同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点")])])])}),[],!1,null,null,null);n.default=s.exports}}]);