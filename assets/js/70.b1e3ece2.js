(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{1075:function(r,t,i){"use strict";i.r(t);var e=i(1),n=Object(e.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[r._v("参考视频："),e("a",{attrs:{href:"https://www.bilibili.com/video/BV16J411h7Rd/?p=76&spm_id_from=pageDriver&vd_source=a8c98c296c32f29367168e837367f0d1",target:"_blank",rel:"noopener noreferrer"}},[r._v("04.027-Monitor-工作原理_哔哩哔哩_bilibili"),e("OutboundLink")],1)]),r._v(" "),e("p",[r._v("Monitor被翻译为监视器或管程")]),r._v(" "),e("p",[r._v("每个java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁(重量级)之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针")]),r._v(" "),e("p",[r._v("Monitor 结构如下所示：")]),r._v(" "),e("img",{attrs:{src:i(532)}}),r._v(" "),e("img",{attrs:{src:i(533)}}),r._v(" "),e("ul",[e("li",[e("p",[r._v("刚开始 Monitor 中 Owner 为空")])]),r._v(" "),e("li",[e("p",[r._v("当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner")])]),r._v(" "),e("li",[e("p",[r._v("在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5，也来执行 synchronized(obj) ，就会进入 EntryList Blocked")])]),r._v(" "),e("li",[e("p",[r._v("Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的")])]),r._v(" "),e("li",[e("p",[r._v("图中 WaitSet 中的 Thread-0，Thread-1，是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify时分析。")])])]),r._v(" "),e("p",[r._v("注意：")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("synchronized 必须是进入同一个对象的 monitor 才有上述的效果")])]),r._v(" "),e("li",[e("p",[r._v("不加 synchronized 的对象不会关联监视器，不遵从以上规则")])])])])}),[],!1,null,null,null);t.default=n.exports},532:function(r,t,i){r.exports=i.p+"assets/img/17.95748d4d.png"},533:function(r,t,i){r.exports=i.p+"assets/img/1.b5c9d4fb.gif"}}]);